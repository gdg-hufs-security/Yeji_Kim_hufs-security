### Objectives

- VM 개발 환경 구축
- 컴퓨터 구조(Computer Architecture)
- 명령어 집합 구조(Instruction Set Architecture, ISA)
- 범용 레지스터(General Register)
- 세그먼트 레지스터(Segment Register)
- 플래그 레지스터(Flag Register)
- 명령어 포인터 레지스터(Instruction Pointer Register, IP)

---

### ✔️컴퓨터 구조

- **CPU**는 컴퓨터의 작동에 핵심이 되는 연산을 처리
- **저장장치**는 데이터를 저장
- **GPU**는 그래픽 데이터 처리
- **랜카드**는 네트워크 통신 관리
- **사운드 카드**는 소리 데이터를 처리

### ✔️**컴퓨터 구조의 세부 분야**

- 기능 구조의 설계
    - 폰 노이만 구조
    - 하버드 구조
    - 수정된 하버드 구조
- 명령어 집합구조(Instruction Set Architecture **=** CPU가 사용하는 명령어와 관련된 설계)
    - x86, x86-64
    - ARM
    - MIPS
    - AVR
- 마이크로 아키텍처(= CPU의 하드웨어적 설계)
    - 캐시 설계
    - 파이프라이닝
    - 슈퍼 스칼라
    - 분기 예측
    - 비순차적 명령어 처리
- 하드웨어 및 컴퓨팅 방법론
    - 직접 메모리 접근

### ✔️**폰노이만 구조**

컴퓨터는 연산과 제어를 위해 **중앙처리장치(Central Processing Unit, CPU)**를, 저장을 위해 **기억장치(memory)**를 사용.

 그리고 장치간에 데이터나 제어 신호를 교환할 수 있도록 **버스(bus)**라는 전자 통로를 사용.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e6507f6-9180-4db1-b0aa-a71b098133d7/7a9270f9-27c6-4047-8f89-89b19d4b9359/image.png)

**중앙처리장치**

CPU는 프로그램의 연산을 처리하고 시스템을 관리하는 컴퓨터의 두뇌. 프로세스의 코드를 불러오고, 실행하고, 결과를 저장하는 일련의 모든 과정이 CPU에서 일어남. CPU는 산술/논리 연산을 처리하는 산술논리장치(Arithmetic Logic Unit, ALU)와 CPU를 제어하는 제어장치(Control Unit), CPU에 필요한 데이터를 저장하는 레지스터(Register) 등으로 구성.

**기억장치**

기억장치는 컴퓨터가 동작하는데 필요한 여러 데이터를 저장하기 위해 사용되며, 용도에 따라 주기억장치와 보조기억장치로 분류. 주기억장치는 프로그램 실행과정에서 필요한 데이터들을 임시로 저장하기 위해 사용. ex) 램(Random-Access Memory, RAM). 이와 반대로 보조기억장치는 운영 체제, 프로그램 등과 같은 데이터를 장기간 보관하고자 할 때 사용. ex) 하드 드라이브(Hard Disk Drive, HDD), SSD(Solid State Drive).

**버스**

버스는 컴퓨터 부품과 부품 사이 또는 컴퓨터와 컴퓨터 사이에 신호를 전송하는 통로를 말합니다. ex) 데이터가 이동하는 데이터 버스(Data Bus), 주소를 지정하는 주소 버스(Address Bus), 읽기/쓰기를 제어하는 제어 버스(Control Bus), 랜선이나 데이터 전송 소프트웨어, 프로토콜 등

**기억장치가 있는데 CPU안에 레지스터가 왜 필요한가?**

CPU의 연산속도가 기억장치와의 데이터 교환속도보다 압도적으로 빠르기 때문에, 기억장치만을 사용하면 병목현상이 발생. 따라서 CPU는 교환속도를 획기적으로 단축하기 위해 레지스터와 캐시라는 저장장치를 내부에 갖는다.

### ✔️**명령어 집합 구조**

**명령어 집합 구조(Instruction Set Architecture, ISA)**란 CPU가 해석하는 명령어의 집합을 의미. 프로그램은 기계어로 이루어져 있는데, 프로그램을 실행하면 이 명령어들을 CPU가 읽고, 처리.

ISA는 IA-32, x86-64(x64), MIPS, AVR 등 다양하게 존재. 이렇게 다양한 ISA가 개발되고 사용되는 이유는 모든 컴퓨터가 동일한 수준의 연산 능력을 요구하지 않으며, 컴퓨팅 환경도 다양하기 때문.

**n 비트 아키텍처**

‘64비트 아키텍처', '32비트 아키텍처’에서 64와 32는 CPU가 한번에 처리할 수 있는 데이터의 크기. 컴퓨터과학에서는 이를 CPU가 이해할 수 있는 데이터의 단위라는 의미에서 **WORD**라고 부름. WORD의 크기는 CPU가 어떻게 설계됐느냐에 따라 달라짐. 예를 들어, 일반적인 32비트 아키텍처에서 ALU는 32비트까지 계산할 수 있으며, 레지스터의 용량 및 각종 버스들의 대역폭이 32비트이다. 따라서 이들로 구성된 CPU는 설계 상 32비트의 데이터까지만 처리할 수 있음.

### ✔️레지스터

**범용 레지스터**

범용 레지스터는 주용도는 있으나, 그 외의 다양한 용도로 사용될 수 있는 레지스터. x86-64에서 각각의 범용 레지스터는 8바이트를 저장할 수 있으며, 부호 없는 정수를 기준으로 264−1까지의 수를 나타낼 수 있음.

| **이름** | **주용도** |
| --- | --- |
| rax (accumulator register) | 함수의 반환 값 |
| rbx (base register) | x64에서는 주된 용도 없음 |
| rcx (counter register) | 반복문의 반복 횟수, 각종 연산의 시행 횟수 |
| rdx (data register) | x64에서는 주된 용도 없음 |
| rsi (source index) | 데이터를 옮길 때 원본을 가리키는 포인터 |
| rdi (destination index) | 데이터를 옮길 때 목적지를 가리키는 포인터 |
| rsp (stack pointer) | 사용중인 스택의 위치를 가리키는 포인터 |
| rbp (stack base pointer) | 스택의 바닥을 가리키는 포인터 |

**세그먼트 레지스터**

x64 아키텍처에는 *cs, ss, ds, es, fs, gs* 총 6가지 세그먼트 레지스터가 존재, 각 레지스터의 크기는 16비트. 세그먼트 레지스터는 x64로 아키텍처가 확장되면서 용도에 큰 변화가 생긴 레지스터.

현대의 x64에서 cs, ds, ss 레지스터는 코드 영역과 데이터, 스택 메모리 영역을 가리킬 때 사용되고, 나머지 레지스터는 운영체제 별로 용도를 결정할 수 있도록 범용적인 용도로 제작됨

**명령어 포인터 레지스터**

프로그램은 일련의 기계어 코드들로 이루어짐. 이 중에서 CPU가 어느 부분의 코드를 실행할지 가리키는게 명령어 포인터 레지스터의 역할. x64 아키텍처의 명령어 레지스터는 *rip*이며, 크기는 8바이트.

**플래그 레지스터**

플래그 레지스터는 프로세서의 현재 상태를 저장하고 있는 레지스터. x64 아키텍처에서는 RFLAGS라고 불리는 64비트 크기의 플래그 레지스터가 존재

깃발을 올리고, 내리는 행위 로 신호를 전달하듯, 플래그 레지스터는 자신을 구성하는 여러 비트들로 CPU의 현재 상태를 표현

RFLAGS는 64비트이므로 최대 64개의 플래그를 사용할 수 있지만, 실제로는 아래 그림의 20여개의 비트만 사용

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/3e6507f6-9180-4db1-b0aa-a71b098133d7/f27cebe8-4bc0-4e1a-b5ed-522c62a7cf6f/image.png)

| **플래그** | **의미** |
| --- | --- |
| CF(Carry Flag) | 부호 없는 수의 연산 결과가 비트의 범위를 넘을 경우 설정 됩니다. |
| ZF(Zero Flag) | 연산의 결과가 0일 경우 설정 됩니다. |
| SF(Sign Flag) | 연산의 결과가 음수일 경우 설정 됩니다. |
| OF(Overflow Flag) | 부호 있는 수의 연산 결과가 비트 범위를 넘을 경우 설정 됩니다. |

**레지스터 호환**

x86-64 아키텍처는 IA-32의 64비트 확장 아키텍처이며, 호환이 가능. IA-32에서 CPU의 레지스터들은 32비트 크기를 가지며, 이들의 명칭은 각각 *eax, ebx, ecx, edx, esi, edi, esp, ebp*. 호환성을 위해 이 레지스터들은 x86-64에서도 그대로 사용이 가능.

*rax, rbx, rcx, rdx, rsi, rdi, rsp, rbp*가 이들의 확장된 형태이며, eax, ebx 등은 확장된 레지스터의 하위 32비트를 가리킴. 마찬가지로, 과거 16비트 아키텍처인 IA-16과의 호환을 위해 *ax, bx, cx, dx, si, di, sp, bp*는 *eax, ebx , ecx , edx, esi, edi, esp, ebp*의 하위 16비트를 가리킴.
